{"componentChunkName":"component---src-templates-note-template-js","path":"/constellation/test-driven-development","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Test Driven Development\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Methods\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Fake it (stub implementations)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"obvious implementation\")), mdx(\"p\", null, \"The reason to articulate it this way is that if you ever get blown away by 2, you can always fall back to 1 and KEEP MOVING.\"), mdx(\"h1\", null, \"Three Steps\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Write failing test\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Write code to make test pass\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Refactor mothafucka\")), mdx(\"h1\", null, \"Iterative Speed\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"brazil-build single-integration-test -DtestClass=\\\"com.amazon.amazonmusicqueueserviceecs.activity.addtoqueue.AddToQueueBoundaryTest\\\"\\n\\nbrazil-build debug-single-integration-test -DtestClass=\\\"com.amazon.amazonmusicqueueserviceecs.activity.addtoqueue.AddToQueueBoundaryTest\\\"\\n\\nbb | grep \\u2718\\n\")), mdx(\"p\", null, \"brazil-build debug-single-integration-test -DtestClass=\\\"com.amazon.amazonmusicqueueserviceecs.activity.setshuffle.SetShuffleOrchestratorTest\\\"\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Don\\u2019t depend on anything volatile like guis or services - \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.notion.so/Clean-Architecture-f3a58bdb34d84a3d91c344a45ad7ccc4\"\n  }, \"Clean Architecture\"))), mdx(\"h1\", null, \"Structural coupling\"), mdx(\"p\", null, \"Test for every production class and method\\nTests are strongly coupled to production.\\nPrevents refactoring and makes code rigid. \"), mdx(\"h1\", null, \"humble data pattern\"), mdx(\"p\", null, \"At architecture boundaries a humble data pattern will often exists. It basically divides classes into easy and hard to test division. Something like data conversions from services or databases. \"), mdx(\"h1\", null, \"captors\"), mdx(\"p\", null, \"use in place of any() being passed into mocks\\nit captures any input being passed into the mock\\nand then you can assert on what you expect the input to be\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"@Captor \\nprivate ArgumentCaptor<IReportDevicePlaybackResponse> responseCaptor;\\n\\nwhen(reportDevicePlaybackResponseConverter.convert(responseCaptor.capture())).thenReturn(externalResponse);\\n\\nassertEquals(response, responseCaptor.getValue());\\n\")), mdx(\"h2\", null, \"potential issues\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"make sure you verify values are called AFTER the subject method is actually ran...\")));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"test-driven-development","frontmatter":{"title":"Test Driven Development"},"excerpt":"Methods Fake it (stub implementations) obvious implementation The reason to articulate it this way is that if you ever get blown away byâ€¦","inboundReferences":[{"frontmatter":{"title":"Design Habit Chain"},"slug":"design-habit-chain"}],"outboundReferences":[]}},"pageContext":{"slug":"test-driven-development"}},"staticQueryHashes":["3000541721"]}